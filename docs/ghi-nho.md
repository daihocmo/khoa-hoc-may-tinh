# Ghi nhớ nào!



## Vấn đề 1: Chúng ta quên quá nhanh

Bạn đã bao giờ dành một tuần để học cho kỳ thi, chỉ để quên 90% những gì bạn đã học trong vòng 2 tháng và mọi thứ khác trong vòng một năm chưa?

Việc quên sẽ cản trở việc học các kỹ năng chuyên sâu về kiến ​​thức như lập trình. Bạn cần phải nhớ nhiều ngôn ngữ, giải pháp, thư viện và các lỗi nếu bạn muốn xây dựng các ứng dụng lớn. Vì tài liệu kỹ thuật có thể rất trừu tượng và khô khan, nên bạn quên rất nhanh.

_Quy tắc đầu tiên của \*_ Janki\*\* giúp tăng cường trí nhớ của bạn:\*
**“Mỗi khi bạn học được điều gì đó mới, hãy tạo một thẻ ghi nhớ câu hỏi và câu trả lời và thêm thẻ này vào Anki.”**
{: .janki-rule}

Anki là một Hệ thống lặp lại theo khoảng cách. Hầu hết các thuật toán đều giúp máy tính hoạt động hiệu quả; Anki giúp bạn hoạt động hiệu quả. Sử dụng số lần lặp lại tối thiểu cần thiết để ghi nhớ lâu dài, Anki sẽ đưa các thẻ ghi nhớ vào bộ nhớ dài hạn của bạn.

Bắt đầu bằng cách tạo một bộ thẻ ghi nhớ được gọi là khoa học máy tính. Một bộ thẻ chứa nhiều thẻ và mỗi thẻ bao gồm một câu hỏi và một câu trả lời. Bạn gắn thẻ các thẻ này bằng các danh mục mô tả tốt nhất nội dung của chúng. Ví dụ, một thẻ có thể được gắn thẻ là 'Rails' và một thẻ khác là 'SQL'. Mỗi thẻ có thể có nhiều thẻ, điều này rất hữu ích vì các công nghệ thường chồng chéo lên nhau.

Theo thời gian, bạn sẽ xây dựng được một kho lưu trữ kiến ​​thức về lập trình, được phân loại rõ ràng, dễ tìm kiếm và được sao lưu thường xuyên trên đám mây. Việc duy trì một kho lưu trữ như thế này rất hữu ích, nhưng nó không giúp bạn lưu giữ kiến ​​thức trong đầu. Chìa khóa để làm được điều này là thực hiện Ankis của bạn.

Mỗi sáng, Anki sẽ tính toán những thẻ nào bạn có nguy cơ quên và sau đó nhắc bạn xem lại những thẻ này. Việc thực hiện Ankis của bạn chỉ mất vài phút mỗi ngày, vì bạn chỉ cần xem lại một phần bộ bài của mình vào bất kỳ ngày nào.

![daily-reviews](https://confessions-production.s3.amazonaws.com/uploads/photo/file/9/daily-reviews.png)

Đối với mỗi thẻ bạn xem lại, Anki sẽ hiển thị cho bạn mặt câu hỏi với mặt câu trả lời ban đầu bị chặn. Nhiệm vụ của bạn là trả lời câu hỏi trong đầu, sau đó tiết lộ câu trả lời và kiểm tra xem bạn đã trả lời đúng chưa. Sau khi bạn trả lời, bốn nút sẽ xuất hiện ở cuối màn hình: "lại nữa", "tốt", "dễ" và "rất dễ". Đánh giá mức độ dễ nhớ lại thẻ đó của bạn và sau đó nhấn nút thích hợp. Dựa trên nút bạn nhấn, Anki sẽ xác định thời điểm tiếp theo để hiển thị thẻ đó cho bạn, vì vậy việc trả lời trung thực là rất quan trọng l nếu bạn muốn thuật toán hoạt động.

![question1](https://confessions-production.s3.amazonaws.com/uploads/photo/file/13/question1.png)

Hãy làm điều này mỗi ngày và bạn sẽ không quên.

## Vấn đề 2: Chúng ta bỏ cuộc quá sớm

Hầu hết mọi người không học được lập trình vì cùng lý do khiến họ không giỏi chơi guitar: họ bỏ cuộc quá sớm. Mặc dù họ luyện tập chăm chỉ trong vài tuần đầu, nhưng họ sớm mất động lực và bỏ cuộc trước khi đạt được kết quả.

Cố gắng học bằng nhịp điệu hoạt động mạnh mẽ trong thời gian ngắn sau đó là những khoảng dừng dài là vấn đề. Tâm trí bạn cần thời gian để tiếp thu những gì học được, vì vậy các kỹ năng học tập không thể được cô đọng trong một tuần. Bằng cách chấp nhận thực tế này và sử dụng phương pháp học tập nhấn mạnh vào nỗ lực gia tăng hàng ngày, bạn sẽ ít có khả năng bị kiệt sức và có nhiều khả năng thành công hơn.

_Quy tắc thứ hai của \*_ Janki\*\* khuyến khích cam kết học tập hàng ngày:\*
**“Bạn phải sử dụng Anki mỗi ngày - bao gồm cả cuối tuần và ngày lễ - và cam kết thực hiện vô thời hạn.”**
{: .janki-rule}

Việc thực hiện Ankis của bạn phải có cùng một thói quen như đánh răng, và bạn nên cảm thấy hư hỏng nếu bạn bỏ lỡ Ankis của mình.

Quy tắc 2 không quá khó như bạn nghĩ lúc đầu. Sau vài tháng luyện tập, bạn sẽ có thể thực hiện Ankis của mình trong 5-8 phút. Việc tìm ra thời gian đó cũng không phải là vấn đề, vì Anki có sẵn trên điện thoại thông minh, nghĩa là bạn có thể xem lại trong khi đi bộ đến nơi làm việc, ngồi trên xe buýt hoặc có một phút rảnh rỗi tại văn phòng. Anki thậm chí còn đồng bộ hóa trạng thái của bộ bài của bạn trên tất cả các thiết bị của bạn, do đó, những thay đổi đối với bộ bài trên máy tính để bàn của bạn sẽ được phản ánh trên tất cả các thiết bị của bạn.

## Vấn đề 3: Chúng ta học ngoài ngữ cảnh

Học ngoài ngữ cảnh là lãng phí. Đọc một cuốn sách giáo khoa từ đầu đến cuối có thể rất thú vị, nhưng nếu những khái niệm đó không liên quan đến các vấn đề kỹ thuật mà bạn đang gặp phải, thì bạn sẽ thiếu bối cảnh tinh thần cần thiết để tiếp thu kiến ​​thức đó một cách hiệu quả. Sự hiểu biết không đầy đủ và công sức lãng phí sẽ xảy ra.

_Quy tắc thứ ba của \*_ Janki\*\* giúp bạn tập trung vào những gì quan trọng trong thời điểm đó:\*
**“Học trong bối cảnh. Chọn một dự án và chỉ học những gì bạn cần để hoàn thành dự án đó.”**
{: .janki-rule}

#### Khi viết bài đăng trên blog này, tôi không biết cách thêm hình ảnh vào ngôn ngữ Textile.

##### Bước 1: Tôi đã tìm kiếm trên Google.

![new-card1](https://confessions-production.s3.amazonaws.com/uploads/photo/file/6/new-card1.png)

##### Bước 2: Tôi đã thử mã bằng cách thêm hình ảnh vào bài đăng.

![new-card2](https://confessions-production.s3.amazonaws.com/uploads/photo/file/10/new-card2.png)

##### Bước 3: Sau khi kiểm tra xem nó có hoạt động không, tôi đã thêm kỹ thuật mới của mình vào Anki Deck.

![new-card3](https://confessions-production.s3.amazonaws.com/uploads/photo/file/11/new-card3.png)

## Vấn đề 4: Chúng ta nghĩ rằng mình có thể học mà không cần thực hành

> _“Tôi đã học về tình dục theo cách khó khăn – từ một cuốn sách.” **Eddie Izzard**_

Giống như tình dục, lập trình sẽ tốt hơn và thú vị hơn khi thành thạo thông qua thực hành. Học mà không thực hành sẽ khiến bạn xa rời thực tế.

Khi bạn đọc về lập trình mà không thử mã, bạn sẽ hình thành một biểu diễn bên trong không đầy đủ, ít hiểu biết và khó áp dụng vào thực tế.

Bạn sẽ không nhận thấy các chi tiết quan trọng. Nhiều thứ có vẻ tầm thường khi bạn lần đầu tiên đọc về chúng trong sách giáo khoa. Có thể là do cách đặt dấu ngoặc kép quanh tham số của hàm hoặc quy tắc về khoảng trắng được phép. Những điểm bị bỏ qua này thường có thể rất quan trọng trong thực tế và bất kỳ điều gì không hiểu đầy đủ sẽ làm giảm năng suất của bạn. Chỉ khi thử viết mã, bạn mới nhận ra được sắc thái của các quy tắc này và thực sự hiểu ngôn ngữ, kỹ thuật và lệnh đang đề cập.

_Quy tắc thứ tư của \*_ Janki\*\* là nền tảng kiến ​​thức trong thực tế:\*
**“Chỉ thêm một lá bài vào bộ bài của bạn sau khi đã thử sử dụng mục kiến ​​thức trong đó.”**
{: .janki-rule}

Giả sử bạn đang làm việc trên một ứng dụng được hỗ trợ bởi cơ sở dữ liệu SQL. Để xây dựng ứng dụng, bạn sẽ cần tham khảo tài liệu về thiết kế cơ sở dữ liệu và SQL (ngôn ngữ truy vấn để chọn bản ghi từ các bảng cơ sở dữ liệu). Khi làm việc trên ứng dụng, bạn sẽ được tiếp xúc với các khái niệm mới. Hãy thử từng kiến ​​thức mới trước khi thêm vào bộ bài Anki của bạn. Ví dụ, nếu bạn đọc về cách xóa một hàng trong bảng cơ sở dữ liệu, thì bạn nên thử xóa một hàng thực tế trong cơ sở dữ liệu của mình trước khi tạo thẻ Anki nêu chi tiết truy vấn SQL đó.

## Vấn đề 5: Chúng ta mắc nhiều lỗi hơn mức cần thiết

Những lỗi lầm trong quá khứ của chúng ta đóng vai trò là công cụ hỗ trợ trí nhớ tuyệt vời. Đây là lý do chính khiến chúng ta học bằng cách thực hành. Tuy nhiên, không phải tất cả các lỗi lầm trong quá khứ đều có hiệu quả như nhau trong việc dạy cho chúng ta bài học; có mối tương quan giữa tác động về mặt cảm xúc của một lỗi và thời gian bài học đó sẽ nằm trong trí nhớ.

Giả sử bạn mắc một lỗi lớn. Bạn vô tình đẩy mã chưa hoàn chỉnh lên máy chủ trực tiếp, khiến ứng dụng của bạn ngừng hoạt động trong 12 giờ. Bạn hoảng sợ để sửa lỗi và khi khách hàng phàn nàn, bạn cảm thấy ngu ngốc và bị bắt. Hình phạt về mặt cảm xúc này đóng vai trò như một lời nhắc nhở mạnh mẽ về lỗi của bạn và bạn sẽ cẩn thận hơn khi đẩy mã lên máy chủ trong tương lai.

Rất may là lỗi có tác động về mặt cảm xúc rất hiếm và bạn không cần **Phương pháp Janki** để học hỏi từ những lỗi này. Nhưng còn những lỗi còn lại mà chúng ta mắc phải thì sao, khi yếu tố cảm xúc bị giảm bớt hoặc thậm chí không có? Chúng ta có thể cần phải mắc những lỗi này nhiều lần trước khi cuối cùng học được bài học của mình.

Lặp lại lỗi là số lần bạn cần mắc một lỗi cụ thể trong suốt cuộc đời trước khi học được bài học vĩnh viễn. Vì lỗi thường tốn kém, đáng xấu hổ và có khả năng đe dọa sự nghiệp, nên việc giảm thiểu sự xuất hiện của chúng là điều hợp lý. Sếp, khách hàng và đồng nghiệp hiểu được lỗi lần đầu tiên và tất cả mọi người, trừ những người vô lý nhất, sẽ tha thứ cho bạn. Tuy nhiên, họ sẽ không cảm thấy dễ tha thứ như vậy khi bạn mắc lỗi lần thứ hai hoặc thứ ba.

_Quy tắc thứ năm của phương pháp \*_ Janki\*\* là giảm thiểu việc lặp lại lỗi.\*
**“Mỗi khi bạn mắc lỗi, hãy tiến hành khám nghiệm tử thi và cố gắng tìm ra bài học kinh nghiệm. Hãy nghĩ về những gì bạn cần biết để ngăn ngừa lỗi đó xảy ra lần nữa và biến hiểu biết này thành những thẻ ghi nhớ mới.”**
{: .janki-rule}

Bằng cách áp dụng quy tắc này, bạn sẽ thay thế những lỗi trong thế giới thực bằng các bài đánh giá Janki và do đó, bạn sẽ học hỏi từ những lỗi của mình nhanh hơn và ít bối rối và mắc lỗi trong thế giới thực hơn.

Việc ghi nhớ những thất bại trong quá khứ không chỉ ngăn ngừa chúng lặp lại. Nó còn giúp bạn hiểu được lĩnh vực của mình, vì hành động thực hiện phân tích sau khi chết và kiểm tra nguyên nhân cơ bản của lỗi sẽ khuyến khích bạn suy nghĩ sâu sắc. Thay vì chỉ tạo ra những thẻ bạn cần để ngăn ngừa lỗi cụ thể đó, bạn có thể tự miễn dịch với toàn bộ loại lỗi đó.

Mỗi lỗi đều trở thành một trải nghiệm học tập. Làm hỏng vẫn tệ, nhưng bạn cảm thấy một chút chiến thắng khi biết rằng mình vừa tìm ra cách để cải thiện và bạn sẽ cảm thấy yên tâm vì chắc chắn rằng mình sẽ không bao giờ mắc lỗi đó nữa.

## Vấn đề 6: Chúng ta không suy ngẫm về bức tranh toàn cảnh

Bằng cách tuân theo năm quy tắc ban đầu của **Phương pháp Janki**, bạn sẽ nhanh chóng trở nên thành thạo với các chi tiết cấp thấp của lập trình: tên và trường hợp sử dụng của các hàm và lệnh, đầu vào dự kiến ​​và đầu ra dự kiến ​​của chúng, giải pháp cho các lỗi phổ biến và các kỹ thuật để giữ cho mã của bạn được tổ chức.

Khi kinh nghiệm của bạn tăng lên, bạn sẽ phải đối mặt với những câu hỏi lớn hơn, chẳng hạn như các quyết định về cấu trúc cho ứng dụng của bạn, các kỹ thuật để giảm thiểu sự phức tạp, quy trình làm việc để quản lý các phiên bản đồng thời của mã của bạn và sự đánh đổi giữa hiệu suất và tính thanh lịch của mã. Trả lời những câu hỏi này đòi hỏi kiến ​​thức sâu rộng và kinh nghiệm đáng kể, và vì lý do này, bạn không bao giờ được bỏ lỡ cơ hội để nâng cao kiến ​​thức của mình về các vấn đề bao quát này.

_Quy tắc thứ sáu của phương pháp \*_ Janki\*\* khuyến khích phản ánh phê phán thường xuyên:\*
**“Vào cuối mỗi dự án, hãy tự hỏi bản thân bạn đã học được những bài học gì và bạn sẽ làm gì khác nếu bạn lặp lại dự án đó với lợi thế là nhìn lại quá khứ.”**
{: .janki-rule}

Sau một dự án lớn, chẳng hạn như hoàn thành một ứng dụng mới, hãy dành thời gian để suy ngẫm. Hãy tự hỏi bản thân những câu hỏi lớn, chẳng hạn như:

- Tôi có lãng phí thời gian vào những ngõ cụt nào không? Có điều gì tôi có thể làm trong tương lai để giúp tôi lường trước những điều này và ngăn chặn chúng xảy ra lần nữa không?
- Tôi đã chọn đúng công nghệ chưa? Tôi có thể đưa ra một sơ đồ để giúp tôi đưa ra những lựa chọn đúng đắn vào lần tới không?
- Tôi đã ước tính chính xác thời gian cần thiết chưa?
- Tôi có thể xây dựng kiến ​​trúc đơn giản hơn không? Tôi có thể tìm ra điều này sớm hơn không?
- Tôi có thể tạo danh sách kiểm tra để dễ dàng phát triển loại tính năng đó trong tương lai không?

Một số câu hỏi này sẽ khó trả lời vì bạn phải chạy qua các phương án thay thế trong đầu, suy nghĩ về lợi ích và sự đánh đổi của từng phương án. Nỗ lực này là xứng đáng vì các quyết định kiến ​​trúc hợp lý sẽ ngăn chặn nỗ lực lãng phí. Nếu không có sự phản ánh tích cực, bạn sẽ ít có khả năng nhận thấy các mô hình cấp độ dự án này và do đó, trí tuệ của bạn sẽ phát triển chậm hơn so với bình thường.

## Vấn đề 7: Chúng ta để các biểu diễn kiến ​​thức của mình trở nên lộn xộn

Giống như một bãi cỏ trước nhà không được sử dụng, bộ bài Anki của bạn có thể trở nên xấu xí. Có lẽ một trong những ngôn ngữ lập trình mà bạn đã học trước đây đã thay đổi đáng kể trong phiên bản 2.0 và hiện tại một phần trăm thẻ của bạn không hợp lệ. Có lẽ một số thẻ của bạn không còn xứng đáng để giữ lại trong quá trình xem xét định kỳ nữa – tính hữu ích của chúng không biện minh cho thời gian sửa đổi tích lũy cần thiết.

Khi bạn học, bạn sẽ khám phá ra những cách đơn giản hơn để hiểu các khái niệm; nếu không cập nhật thẻ của mình để phản ánh các mô hình cải tiến này, bạn có nguy cơ mất đi những hiểu biết này mãi mãi. Thông thường, một nhóm thẻ có thể được thay thế bằng một thẻ duy nhất trên một khái niệm bậc cao hơn.

Đôi khi bạn sẽ thấy các liên kết giữa các thẻ trong bộ bài của mình. Nếu bạn lưu ý kết nối giữa các thẻ này, bạn sẽ tạo ra nhiều đường dẫn thần kinh đến cùng một em kiến ​​thức. Nếu một con đường thất bại, bạn vẫn có thể đến và kích hoạt kiến ​​thức đó từ một con đường khác. Khả năng của bản đồ tư duy giúp bạn ghi nhớ hoạt động bằng cách sử dụng một ý tưởng tương tự. Bằng cách tìm kiếm và ghi chú những kết nối này trong bộ bài của bạn, bạn thêm một lớp dự phòng vào biểu diễn kiến ​​thức của mình, giúp đảm bảo hơn nữa việc không bị lãng quên trong tương lai,

_Quy tắc thứ bảy của \*_ Janki\*\* giữ cho bộ bài của bạn luôn trong tình trạng tốt.\*
**“Xóa hoặc sửa đổi bất kỳ thẻ nào không chính xác, lỗi thời, khó nhớ, không đầy đủ hoặc không cần thiết. Cập nhật các thẻ hiện có khi hiểu biết được cải thiện.”**
{: .janki-rule}

### Sau đây cho thấy sự hiểu biết kém về Git, sau đó được cập nhật với sự hiểu biết sắc thái hơn.

![poor-understanding](https://confessions-production.s3.amazonaws.com/uploads/photo/file/12/poor-understanding.png)![better-understanding](https://confessions-production.s3.amazonaws.com/uploads/photo/file/8/better-understanding.png)

## Vấn đề 8: Chúng ta không tham chiếu đến các nguồn chính

Các nhà thiết kế đồ họa, nghệ sĩ, kiến ​​trúc sư và những người sáng tạo khác giữ lại những cuốn sổ lưu niệm về các thiết kế mà họ thích. Sau đó, khi làm việc trên một dự án, họ lấy cảm hứng từ chính những cuốn sổ lưu niệm này.

Là một lập trình viên, nguồn cảm hứng chính của bạn sẽ là mã của người khác. Tải xuống các dự án nguồn mở (ví dụ: trên [Github](http://www.github.com)) và đọc qua mã. Tra cứu các phần bạn không hiểu và tạo các thẻ mới nếu cần. Lấy bút và giấy, phác thảo các đường dẫn qua chương trình. Đầu vào là gì và đầu ra mong đợi là gì? Dữ liệu sẽ ra sao khi nó di chuyển qua chương trình? Tại sao nó được thiết kế theo cách này? Những kỹ thuật nào đã được sử dụng?

Bằng cách đọc mã, bạn sẽ được tiếp xúc với nhiều phong cách lập trình và giải pháp khác nhau cho các vấn đề lập trình. Bạn sẽ thấy những thứ bạn thích và rất nhiều thứ bạn không thích. Theo thời gian, bạn sẽ tìm thấy phong cách riêng của mình.

_Quy tắc thứ tám của \*_ Janki\*\* khuyến khích bạn sử dụng các bài đọc mã của người khác làm nguồn học tập:\*
**“Đọc mã thường xuyên. Nếu bạn bắt gặp điều gì đó thú vị - có thể là thuật toán, bản hack hoặc quyết định về kiến ​​trúc - hãy tạo một thẻ nêu chi tiết về kỹ thuật và hiển thị mã.”**
{: .janki-rule}

Mục tiêu ban đầu của tôi khi sử dụng Anki để học là để ngăn mình quên và Anki đã thực hiện được lời hứa này. Điều tôi không ngờ tới là những lợi thế thứ cấp xuất hiện thông qua việc sử dụng hàng ngày trong thời gian dài.

## Ưu điểm 1: Lập trình nhanh hơn

Biết hàng nghìn lệnh giúp tiết kiệm thời gian nếu không sẽ phải dành thời gian để tra cứu tài liệu tham khảo. Bạn ngay lập tức nhớ lại các giải pháp trước đây khi gặp phải một vấn đề, và hàng tá khả năng hiện ra trong đầu khi thiết kế một hệ thống. Bạn sẽ đọc mã của người khác một cách nhanh chóng, tự tin vào sự hiểu biết của mình. Phép loại suy gần nhất là sự trôi chảy trong ngôn ngữ tự nhiên. Bạn sẽ nói được mã.

Phần lớn thời gian tôi dành cho lập trình là để gỡ lỗi, tức là sửa lỗi trong mã của bạn hoặc trong mã của các lập trình viên khác. Đây là nơi kiến ​​thức sâu rộng về nền tảng sẽ giúp bạn tăng tốc nhất. Gỡ lỗi chủ yếu bao gồm việc thu thập thông tin. Hệ thống được cho là phải làm gì? Dữ liệu nào có trong hệ thống khi chúng tôi thấy lỗi? Điều gì có thể đã xảy ra sai? Thông thường, một dòng mã lỗi có thể là nguyên nhân gây ra lỗi khiến toàn bộ trang web bị sập. Phần khó là tìm ra dòng logic nào trong số hàng nghìn dòng logic gây ra sự cố.

Hãy lấy một ví dụ. Giả sử chương trình của bạn sử dụng 100 hàm và 70 trong số đó được tích hợp sẵn trong ngôn ngữ. Điều đó có nghĩa là có 30 hàm được xác định tùy chỉnh. Nếu bạn biết chắc chắn các đầu vào và đầu ra của 70 hàm tích hợp, thì việc gỡ lỗi sẽ trở nên đơn giản hơn, vì bạn chỉ cần tìm ra cách thức hoạt động của 30 hàm tùy chỉnh còn lại. Xem xét rằng các hàm tùy chỉnh được định nghĩa theo các hàm tích hợp, nhiệm vụ này cũng không mất quá nhiều thời gian. Hoàn toàn chắc chắn về cú pháp, đầu vào, đầu ra và cách sử dụng các hàm tích hợp cho phép bạn nhanh chóng cô lập các ẩn số và đưa lỗi ra ánh sáng.

Khả năng động não được cải thiện thông qua **Phương pháp Janki.** Kiến thức sâu rộng trong đầu có nghĩa là bạn có thể thử các phương án thay thế trên giấy một cách nhanh chóng và do đó tăng cơ hội tìm ra giải pháp không hiển nhiên cho vấn đề của mình.

Bạn có thể lập luận rằng bạn sẽ đạt được tốc độ tăng tương tự với kiến ​​thức có được thông qua kinh nghiệm. Điều đó đúng, nhưng lập luận này không đúng trọng tâm. Janki cho phép bạn có được cùng kiến ​​thức đó nhanh hơn và ghi nhớ lâu hơn. Nếu bạn đã từng quên cách làm một việc gì đó sau khi để nó sang một bên trong vài tháng, thì Anki là dành cho bạn.

## Ưu điểm 2: Chunking

Kỹ năng trong một lĩnh vực kỹ thuật là sản phẩm của trí thông minh và kiến ​​thức của bạn. Điểm yếu ở một lĩnh vực có thể bị lu mờ bởi điểm mạnh ở lĩnh vực khác. Người thông minh nhưng thiếu kinh nghiệm có thể ngang bằng với người chậm chạp nhưng có kinh nghiệm.

Điểm này được minh họa tốt nhất bằng ví dụ. Hãy nhân 130 với 30 bằng hai cách tiếp cận.

**Cách tiếp cận 1**: Bạn biết rằng phép nhân là phép cộng lặp lại, vì vậy bài toán trở thành 130 + 130 + 130... và cứ thế. Áp dụng các quy tắc cộng, cuối cùng bạn sẽ đạt được 3900. Chúng ta hãy gọi trí thông minh là khả năng thực hiện các phép tính riêng lẻ này một cách nhanh chóng.

**Cách tiếp cận 2**: Có lẽ bạn nhớ từ bảng cửu chương ở trường rằng 13 X 3 bằng 39. Bạn cũng có thể nhớ rằng các tính chất giao hoán và kết hợp của phép nhân cho phép bạn đơn giản hóa 130 X 30 thành 10 X 13 X 3 X 10 và cuối cùng thành 39 X 100, có thể tính toán một cách đơn giản là 3900. Trí thông minh của bạn, hay tốc độ cộng ở đây, không liên quan vì kiến ​​thức chuyên môn cho phép bạn đơn giản hóa bài toán một cách đáng kể.

Trong cách tiếp cận 1, bài toán đòi hỏi nhiều công sức vì bạn không sử dụng kiến ​​thức để tính toán dễ dàng. Điều này không đúng trong cách tiếp cận 2, khi bạn lý luận bằng cách sử dụng các khối kiến ​​thức bậc cao hơn, do đó giải quyết một bài toán dài một cách dễ dàng. Việc áp dụng các khối kiến ​​thức đã nhớ vào các vấn đề đang giải quyết được gọi là **chunking**.

> Nếu bạn nhớ câu trả lời cho một câu hỏi, bạn không cần phải suy luận ngay tại thời điểm đó, do đó, tâm trí bạn được tự do suy luận ra các khái niệm trừu tượng hơn. Đây chính là giá trị của chunking.

**Phương pháp Janki** khuyến khích chunking. Đây là một lợi ích bất ngờ, nhưng cuối cùng lại là lợi ích hữu ích nhất đối với tôi. Sau sáu tháng áp dụng hàng ngày, bạn sẽ lý giải được các khái niệm lập trình bằng các phím tắt trong đầu tương đương với các phím tắt được sử dụng để đơn giản hóa bài toán nhân trong cách tiếp cận 2. Tối đa hóa chunking bằng cách thêm các quy tắc và khái niệm ngày càng trừu tượng vào bộ bài của bạn và cố gắng sử dụng các ý tưởng này khi giải quyết vấn đề.

## Ưu điểm 3: Lưu trữ có thể tìm kiếm được tất cả kiến ​​thức lập trình của bạn

Máy tính của bạn đã bao giờ đưa ra thông báo lỗi và mặc dù bạn nhớ đã thấy lỗi trước đó, nhưng bạn không nhớ cách sửa lỗi không? Trước khi tôi bắt đầu **Phương pháp Janki**, điều này thường xảy ra với tôi.

Lần đầu tiên tôi thấy vấn đề, tôi sẽ dành nửa ngày để giải quyết vấn đề. Sáu tháng sau, vấn đề lại xảy ra, có lẽ ở dạng hơi khác một chút. Mặc dù tôi mơ hồ nhận ra rằng mình đã từng thấy nó trước đây, nhưng tôi đã quên cách sửa nó.

Điều này thật lãng phí và tôi không thích. Tôi không thích phải giải quyết cùng một vấn đề hai lần. **Phương pháp Janki** giúp ngăn chặn điều này xảy ra.

Anki có tính năng tìm kiếm tìm thấy tất cả các thẻ trùng khớp trong bộ bài của bạn. Bạn thậm chí có thể lọc theo ngày hoặc thẻ. Ví dụ, bạn có thể tìm kiếm qua các thẻ có chứa từ "ssh" được tạo cách đây hơn 6 tháng và được gắn thẻ là 'triển khai'.

![search](https://confessions-production.s3.amazonaws.com/uploads/photo/file/14/search.png)

Sau khi giải quyết một lỗi, bạn nên luôn thêm một số thẻ vào bộ bài của mình có chứa kiến ​​thức cần thiết để ngăn lỗi đó xảy ra lần nữa. Tốt hơn nữa, hãy trừu tượng hóa một cấp độ và thêm các thẻ có chứa kiến ​​thức cần thiết để ngăn loại lỗi đó. Bây giờ, bất cứ khi nào bạn gặp lỗi lần thứ hai, tất cả những gì bạn cần làm là tìm kiếm kho lưu trữ của mình.

## Ưu điểm 4: Không phát minh lại bánh xe

Các ngôn ngữ lập trình hiện đại có nhiều thuật toán được tích hợp sẵn hoặc dễ dàng đưa vào như một phần của thư viện cốt lõi có sẵn. Điều này đặc biệt đúng với các ngôn ngữ cấp cao như Ruby và Python. Bạn muốn sắp xếp một mảng? Array#sort sẽ giúp bạn.

Nếu bạn không biết thuật toán sắp xếp được tích hợp sẵn trong ngôn ngữ, thì bạn có thể tự viết thuật toán của riêng mình thay thế. Khi làm như vậy, bạn có nguy cơ mắc lỗi và bỏ lỡ các tối ưu hóa cấp thấp. Hơn nữa, bạn sẽ khiến những người dùng mã của mình trong tương lai xa lánh, những người có thể nghĩ rằng có lý do khác ngoài sự thiếu hiểu biết khiến bạn viết thuật toán sắp xếp tùy chỉnh thay vì sử dụng thuật toán được tích hợp sẵn trong ngôn ngữ.

Bằng cách lấp đầy bộ bài của bạn bằng các thuật toán tích hợp sẵn từ các ngôn ngữ bạn đã chọn, bạn sẽ ít có khả năng vô tình triển khai các tính năng hiện có theo cách gây nhầm lẫn, hời hợt và dễ xảy ra lỗi.

## Tôi có nên tải xuống bộ bài của người khác không?

Anki có cơ sở dữ liệu trực tuyến có thể tìm kiếm về các bộ bài chia sẻ của người khác. Mặc dù không có nhiều bộ bài dành cho khoa học máy tính, nhưng bạn có thể tìm thấy một số bộ bài và ghép chúng lại với nhau làm cơ sở cho bộ bài của mình.

Hãy cẩn thận với điều này. Bạn có thể thêm các sự kiện vào bộ bài của mình mà không có ích cho bạn và bạn có thể xem lại các sự kiện mà bạn không hiểu đầy đủ, do đó tạo ra nền tảng kém cho kiến ​​thức trong tương lai.

Lý tưởng nhất là bạn nên tự xây dựng bộ bài của mình từ đầu, dựa trên kinh nghiệm lập trình của bạn; đọc mã của người khác, sách giáo khoa; xem các bản ghi màn hình giáo dục; và xem lại các lỗi trong quá khứ và các dự án trước đó. Bằng cách tạo bộ bài của mình theo cách này, bạn sẽ giữ cho chúng chứa đầy kiến ​​thức ngữ cảnh thực tế được hiểu rõ, được diễn đạt và phân loại theo cách mà bạn hiểu.

Nếu bạn định sử dụng bộ bài của người khác, hãy đảm bảo rằng bạn hiểu mọi lá bài bạn học được. Hãy chắc chắn rằng bạn thử mã khi bạn nhìn thấy nó lần đầu tiên; điều này đòi hỏi nhiều kỷ luật hơn bạn có thể có. Hãy đảm bảo rằng bạn tin tưởng tác giả của bộ bài - bạn không muốn học những kiến ​​thức không chính xác hoặc lỗi thời, và thật đáng buồn là hầu hết các bộ bài đều miễn phí. 
ailable thì tệ hại.

Một giải pháp thay thế tốt mà tôi muốn giới thiệu là [Chương trình thực thi](https://www.executeprogram.com/) của Gary Berndhart — ông ấy đã tỉ mỉ đặt hàng một giáo trình SRS để có tiến trình học tập tuyệt vời.

## Kiến thức nào thuộc về Bộ bài của tôi và kiến ​​thức nào thì không?

Khi tôi mới bắt đầu **Phương pháp Janki**, tôi đã quá nhiệt tình trong việc thêm các sự kiện vào bộ bài của mình. Đặc biệt, tôi đã thêm các chồng thẻ cho các thư viện mã của bên thứ ba. Điều này hóa ra lại lãng phí, vì tôi hiếm khi sử dụng kiến ​​thức này. Công nghệ phát triển nhanh chóng và các thư viện thịnh hành ngày nay trở thành hành lý của ngày mai từ quá khứ. Cuối cùng, tôi đã xóa nhiều thẻ này sau khi đã lãng phí chúng vào bộ nhớ dài hạn.

Không phải lúc nào cũng dễ dàng phân biệt giữa kiến ​​thức đáng để giữ lâu dài và kiến ​​thức chỉ cần dùng trong thời gian ngắn Để giúp tôi đưa ra quyết định, tôi đã đưa ra sơ đồ này:

Chỉ nhập một lá bài vào bộ bài của bạn nếu đáp ứng một trong các điều kiện sau:

- a) Sự kiện chứa đựng kiến ​​thức chung về khoa học máy tính (tái cấu trúc, biểu thức chính quy, lập trình hướng đối tượng, các vấn đề về bộ nhớ, v.v.).

- b) Sự kiện liên quan đến một công nghệ chính đã tồn tại trong một thời gian dài và có lẽ sẽ tồn tại lâu dài (Linux, Ruby, Javascript, VIM, git, HTML, CSS, SQL)

- c) Sự kiện, mặc dù là một phần của thư viện có khả năng thay đổi, nhưng là thứ tôi sử dụng hàng ngày và là thứ tôi dự kiến ​​sẽ sử dụng trong một thời gian. Điểm thưởng nếu công nghệ có nhu cầu cao, vì điều này tương đương với tỷ lệ tư vấn cao hơn. (Rails, jQuery).

## Tôi cần biết những phím tắt chính nào?

Bạn sẽ xem lại các lá bài của mình hàng ngày nên việc tiết kiệm thời gian nhỏ ở đây sẽ nhanh chóng tăng lên. Các phím tắt rất quan trọng.

Nhấn **Enter** để hiển thị câu trả lời và sau đó đánh giá phản hồi của bạn bằng các phím **0**, **1**, **2** hoặc **3**.

**Command + Backspace** xóa một thẻ. Sử dụng phím này cho các thẻ có vấn đề/không chính xác/cũ.

**Command + E** cho phép bạn chỉnh sửa một thẻ và sau đó **Tab** di chuyển con trỏ giữa các ô câu hỏi và câu trả lời.

Bạn muốn học lập trình và bắt đầu xây dựng các ứng dụng mạnh mẽ? Vậy thì hãy tham gia thử thách Janki. Tải xuống Anki (liên kết bên dưới), chọn một dự án lập trình và công khai thông báo với bạn bè rằng bạn đã cam kết học lập trình.

_Tại sao phải cam kết công khai? Cam kết công khai tạo ra áp lực xã hội thúc đẩy bạn thực hiện lời hứa với thế giới. Áp lực này sẽ giúp bạn vượt qua những giai đoạn đầu khó khăn, khi bạn dễ từ bỏ nhất._

Tôi tin rằng nếu bạn làm theo hệ thống chính xác như mô tả ở trên, bạn sẽ học lập trình nhanh hơn đáng kể so với khi sử dụng bất kỳ phương pháp nào khác ngoài gia sư một kèm một.

- [5500 thẻ ghi nhớ phát triển web, do tôi tạo](http://www.oxbridgenotes.com/other/web_development_flashcards)
- [Anki - Có thể tải xuống miễn phí](http://ankisrs.net/)
- [20 quy tắc để xây dựng kiến ​​thức trong học tập](http://www.supermemo.com/articles/20rules.htm)
- [Bạn muốn ghi nhớ mọi thứ bạn sẽ học? Hãy đầu hàng thuật toán này](http://www.wired.com/medtech/health/magazine/16-05/ff_wozniak?currentPage=all)
- [Thiên tài và sáng tạo](http://www.supermemo.com/articles/genius.htm)


Bài được dịch bởi Google Dịch và chưa chỉnh sửa.

Trong vài năm trở lại đây, tôi đã [làm ầm ĩ](http://www.jackkinsella.ie/2011/12/05/janki-method.html) về [sử dụng thẻ ghi nhớ lặp lại cách quãng để tăng tốc quá trình học lập trình.](http://www.oxbridgenotes.com/other/web_development_flashcards) Tôi biết rằng tính mới lạ của một ý tưởng có thể làm lu mờ đánh giá hợp lý về tính hữu ích của nó, vì vậy mục đích của bài đăng này là theo dõi sự nhiệt tình ban đầu của tôi và tinh chỉnh phương pháp luận của tôi sau một năm kinh nghiệm trong việc đánh giá thẻ hàng ngày không bao giờ thất bại.

Tôi đã cô đọng điều này thành dạng điểm để tiết kiệm thời gian cho cả hai chúng ta. Mỗi tiểu mục đại diện cho một nguyên tắc mà tôi đã áp dụng trong chiến lược học tập của mình, mục tiêu bao quát là nghiên cứu càng nhiều tài liệu càng tốt trong thời gian ngắn nhất.

### 1\. Thẻ ảnh chụp màn hình > Thẻ văn bản thuần túy.

Trong phương pháp ban đầu của mình, tôi đã dán các đoạn mã văn bản thuần túy vào bộ bài của mình. Bây giờ tôi chụp ảnh màn hình (sử dụng phím tắt) các ví dụ mã từ các chương trình tôi mở trong trình soạn thảo văn bản, từ sách lập trình và từ các trang web như Stack Overflow. Tôi tiết kiệm được thời gian, không cần phải nhập lại mã vào Anki. Tôi cũng được tô sáng cú pháp miễn phí, cho phép tôi đọc thẻ nhanh hơn và tăng tốc độ đánh giá của mình.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/scrapbook-expert.jpeg)

Cho phép tôi thêm một số trực giác khoa học không nghiêm ngặt theo phong cách Tim Ferris: Tôi tin rằng ảnh chụp nguồn gốc của sự kiện được ghi trên thẻ nhớ flash của bạn hỗ trợ trí nhớ trên cơ sở i) trí nhớ dựa trên vị trí mạnh hơn những loại khác; và ii) màu sắc, phông chữ và URL trang web tạo ra trí nhớ phong phú hơn, độc đáo hơn so với một thẻ văn bản khác và do đó dễ dàng đưa vào bộ nhớ hơn một chút.

### 2\. Tập trung vào chức năng có sẵn thay vì thông tin chi tiết

Ban đầu, tôi đưa thông tin chi tiết về mọi chức năng vào bộ bài của mình, bao gồm tên lớp, giá trị trả về và kiểu của chúng, danh sách đối số, thứ tự của chúng. Qua nhiều năm, tôi thấy rằng thông tin này trở nên khó nhớ khi bạn thêm các ngôn ngữ lập trình khác vào hỗn hợp, đặc biệt là những ngôn ngữ có tên hàm tương tự (ví dụ: each()) nhưng cách sử dụng hơi khác một chút. Việc chuyển từ ngôn ngữ này sang ngôn ngữ khác khiến tôi nhận ra rằng thông tin chi tiết như vậy mang lại lợi thế ngắn hạn về tốc độ nhưng nhanh chóng trở nên cũ kỹ. Tuy nhiên, tôi rất vui vì mình có một ngôn ngữ "mẹ đẻ" (Ruby đối với tôi) ở mức độ quen thuộc này vì điều đó có nghĩa là tôi có thể phác thảo phần mềm tiện ích cá nhân, tập lệnh và bản hack một cách nhanh chóng.

Quan trọng hơn là phải ghi nhớ là nhận thức về _những_ chức năng tích hợp nào tồn tại trong một ngôn ngữ và những dịch vụ nào tồn tại trong một hệ điều hành hoặc giao thức. Tôi tạo thẻ cho nhiều lệnh linux khác nhau hoặc các thuộc tính cửa sổ tích hợp Javascript hữu ích.

Đôi khi, tôi tạo ra cái mà tôi gọi là "thẻ lai" kết hợp tóm tắt về lệnh _là_ gì với các chi tiết về hoạt động của lệnh đó. Để làm được điều này, tôi làm theo câu trả lời cơ bản "nó là gì" với mô tả chi tiết hoặc ảnh chụp màn hình mã đang sử dụng (có đối số và đầu ra thực tế), tương tự như cách người học ngôn ngữ cung cấp vốn từ vựng mới bằng các câu ví dụ. Khi xem lại các thẻ, tôi tùy ý liếc qua ví dụ về hàm đang sử dụng, nhưng tôi không cố gắng học thuộc lòng. Nếu sau này, tôi tình cờ cần tính năng cụ thể đó cho một dự án, tôi có thể tách riêng các thẻ đó (sử dụng chức năng khoan của Anki) và tìm hiểu thông tin chi tiết hơn.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/hybrid.jpeg)

### 3\. Thẻ sổ lưu niệm

Các nhà thiết kế đồ họa lưu giữ sổ lưu niệm về tác phẩm nghệ thuật và thiết kế mà họ ngưỡng mộ, sau đó tham khảo sổ lưu niệm của họ khi tìm kiếm cảm hứng cho các dự án trong tương lai. Các lập trình viên cũng có thể làm như vậy. Bất cứ khi nào bạn thấy một đoạn mã đặc biệt thanh lịch, hiệu quả hoặc thông minh trong thư viện, bài đăng trên blog hoặc ghi chú hoặc chụp ảnh màn hình rồi đặt vào bộ bài của bạn.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/characterising-variable-names.jpeg)

Để chuyển đổi ảnh chụp ví dụ về mã thành cặp câu hỏi/trả lời thân thiện với Anki, tôi tạo một thẻ có câu hỏi trước ảnh chụp màn hình, đại loại như: "Đoạn mã này có gì tuyệt vời?". Trong câu trả lời, tôi xác định điểm mạnh của kỹ thuật bằng các dấu đầu dòng, buộc bản thân phải xác định và diễn đạt bằng lời những điều mình học được, thay vì chỉ để đó là lời cảm ơn mơ hồ không lời.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/abstain-generic-variable-names.jpeg)

Đôi khi tôi đảo ngược quy trình này và phân tích mã tệ hại, tạo thẻ "Cái này có vấn đề gì?", một lần nữa xây dựng các quy tắc hoặc đơn thuốc chống lại những gì tệ hại. Mục tiêu cuối cùng của cả hai quy trình này là nhận thức nhanh chóng về chất lượng trong chương trình lập trình của riêng tôi.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/IMG_669C6DDCBEB9-1.jpeg)

### 4\. Thông tin có thứ tự không ankify tốt

Ban đầu tôi nghĩ rằng bất kỳ và tất cả các kiến ​​thức kỹ thuật đều ankify tốt. Kể từ đó, tôi đã giảm bớt sự nhiệt tình của mình iasm và nhận thấy một ngoại lệ chính: thông tin mà thứ tự/cấu trúc là cần thiết. Ví dụ, tôi đã tạo các thẻ mở rộng về thiết lập khóa SSH trên máy chủ, một điệu nhảy phức tạp, nhiều bước giữa máy tính xách tay của bạn và máy chủ từ xa của bạn. Mặc dù đã xem lại Anki-fed, tôi không bao giờ nhớ toàn bộ quy trình đã sắp xếp trong thực tế và luôn phải dùng đến hướng dẫn trực tuyến. Thời gian tôi ank hóa và xem lại các quy tắc SSH đã bị lãng phí.

Tôi không chắc nguyên nhân chính xác khiến mình thất bại. Có lẽ tôi đã tạo thẻ ghi nhớ không đúng cho loại thông tin này và tôi có thể đã sửa bằng các thẻ ghi nhớ SSH bổ sung đặt câu hỏi rõ ràng về hành động nào diễn ra trước hoặc sau hành động khác. Nhưng trực giác của tôi cho thấy việc tạo quá nhiều thẻ bổ sung là lãng phí thời gian và tôi muốn giữ lại và dùng đến danh sách kiểm tra hoặc sơ đồ đã cập nhật của quy trình đã sắp xếp.

### 5\. Tạm dừng công nghệ khi đang chờ. Thực hành khi cần.

Tôi quyết định rằng các công nghệ bên lề (ngôn ngữ, thư viện, bộ tính năng và khái niệm hiếm khi được sử dụng trong công việc của tôi) không phải là cách sử dụng tốt cho thời gian đánh giá hạn hẹp của tôi và sau khi tôi đánh giá tài liệu này trong bối cảnh của một dự án sử dụng chúng (ví dụ: sử dụng Backbone cho ứng dụng web vào năm ngoái), tôi tạm dừng đánh giá các thẻ đó. Nếu có một dự án khác sử dụng công nghệ đó, tôi sử dụng **chức năng khoan** của Anki để nhanh chóng sửa đổi công nghệ trước khi bắt tay vào thực hiện. Nếu dự án đó không bao giờ thành hiện thực, tôi sẽ tạm dừng các thẻ vô thời hạn, có lẽ sẽ không bao giờ sử dụng lại nữa.

Bạn có thể chỉ ra rằng việc tạo thẻ Anki cho công nghệ bên lề là lãng phí ngay từ đầu‚Äî có thể là đối với bạn nhưng i) Tôi thấy khó xác định công nghệ bên lề so với công nghệ cốt lõi khi lần đầu tiên tiếp xúc và hơn nữa, ii) Tôi thấy tính kỷ luật khi chủ động chuyển tài liệu kỹ thuật thành câu hỏi và câu trả lời giúp tôi tập trung vào việc đọc và giúp tôi thẩm vấn văn bản để có thông tin có thể hành động nhanh hơn.

### 6\. Giảm Cường Độ

Lý thuyết sử dụng SRS chuẩn (do P. Wozniak đưa ra) yêu cầu chúng ta xem lại tất cả các lá bài trong bộ bài của mình đến hạn vào bất kỳ ngày cụ thể nào để ghi nhớ kiến ​​thức vào bộ nhớ dài hạn với hiệu quả cao nhất có thể. Tôi đã thử cách này trong khoảng hai năm nhưng cuối cùng tôi thấy gánh nặng xem lại quá lớn. Để khắc phục điều này, tôi đã giới hạn số lượng bài xem lại tối đa trong bộ bài lập trình của mình ở mức 40 lá bài mỗi ngày và sửa đổi cài đặt bộ bài trong Anki để tăng phần thưởng dễ (thời gian thêm giữa các lá bài bạn đánh dấu là dễ) và bộ điều chỉnh khoảng thời gian (thời gian giữa các lần xem lại _bất kỳ_ lá bài nào). Hiệu ứng của tùy chọn khoảng cách dễ là hiển thị các lá bài dễ ít thường xuyên hơn (chúng không gây ra thử thách liên tục cho tôi, thường là nền tảng cho các khái niệm nâng cao hơn trong bộ bài của tôi, vì vậy sự đánh đổi là hợp lý), trong khi bộ điều chỉnh khoảng thời gian điều chỉnh thuật toán để giãn cách tất cả các lá bài xa hơn bất kể độ khó, nghĩa là nhiều ngày hơn giữa mỗi lần xem lại và do đó ít bài xem lại hơn vào bất kỳ buổi sáng cụ thể nào.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/lower-intensity.jpeg)

Cái giá tôi phải trả cho thời gian ôn tập giảm này là tôi có thể không ôn tập theo "đường cong quên", nghĩa là một chiến lược học tập kém hiệu quả trên toàn cầu. Tôi chấp nhận điều này vì tôi nhận ra rằng các ngôn ngữ lập trình đến rồi đi và tôi nhận ra rằng tôi có thể không lập trình trong 10 năm nữa‚Äîmục tiêu chính của tôi là lập trình nhanh như tôi có thể rèn luyện bản thân ngày hôm nay. Bên cạnh đó, việc giảm hiệu quả là cái giá hợp lý phải trả nếu nó đảm bảo bạn tuân thủ thói quen ôn tập, thực hiện chức năng tương tự như những ngày gian lận trong chế độ ăn kiêng giảm cân khó khăn.

### 7\. Đọc có đánh số

Bất cứ khi nào tôi đọc sách giáo khoa lập trình in, tôi đều đánh số (1,2,3...) vào lề bên cạnh bất kỳ điểm nào tôi muốn cam kết sau này với Anki, cùng với một lời nhắc ngắn, ví dụ: "hiệu quả của hệ thống tệp". Sau khi đọc xong cuốn sách, tôi lại lướt qua nó một lần nữa, thêm một thẻ vào Anki cho mỗi điểm được đánh số mà tôi vẫn thấy đáng nhớ.

Lý do tôi làm như vậy là i) không làm gián đoạn dòng đọc bằng cách cúi xuống máy tính xách tay và đánh dấu từng điểm tôi gặp phải, do đó tiết kiệm thời gian bằng cách nhóm và ii) để tính đến cách tác giả sách giáo khoa đôi khi trình bày một điểm rõ ràng hơn trong các chương sau và chỉ sử dụng lời giải thích tốt nhất trong bộ thẻ ghi nhớ của tôi.

### 8\. Nhấn mạnh các meme bất biến của ngôn ngữ

Khi học ngôn ngữ lập trình và thư viện, tôi nhận ra rằng một phần giá trị của việc áp dụng phương pháp Janki trong ngôn ngữ lập trình đầu tiên của tôi, Ruby, là học các "meme" lặp lại trong các ngôn ngữ khác. Ví dụ, các phương thức "chức năng" trong mô-đun Enumerable của Ruby, chẳng hạn như each(), map(), select(), reject() và zip() lặp lại dưới cùng tên hoặc tên tương tự trong Javascript, Lisp, Python và nhiều thư viện khác (chẳng hạn như thư viện Underscore của Javascript). Biết ý nghĩa của các hàm này và cách sử dụng chúng sẽ giúp giảm thời gian học một môi trường mới. Tương tự như vậy, việc tìm hiểu chi tiết về cách Linux tương tác với các tệp làm sáng tỏ các phương thức tương tác Tệp/IO trong Ruby, C và Pyth trên.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/explanation-card.jpeg)

Tôi không có cách nào chắc chắn để phân biệt các meme bất biến ngôn ngữ với các ý tưởng "chỉ dành cho ngôn ngữ này", ngoại trừ một vài quy tắc chung. Ví dụ về mã thanh lịch hoặc mã xấu xí (chẳng hạn như số ma thuật) thường có sự tương đồng trong các môi trường khác (hoặc, nếu chưa song song, thì thực hành này có thể được thụ phấn chéo hiệu quả); các hàm tương tác với Hệ điều hành cơ bản (luồng, IO), miễn là chúng không bị trừu tượng hóa, tái sử dụng các khái niệm giống như các ngôn ngữ khác chạy trên các hệ thống tương tự (linux, Android, iOS, Windows); nhiều ngôn ngữ chia sẻ cùng các ý tưởng về biểu thức chính quy (mặc dù có nhiều cú pháp khác nhau); các khái niệm như toán nhị phân, mã hóa chuỗi, tối ưu hóa hiệu suất, gỡ lỗi và lập trình hướng đối tượng vẫn tồn tại mạnh mẽ qua các rào cản ngôn ngữ.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/IMG_4F99DF5CCBF2-1.jpeg)

### 9\. Tự chạy mã sau nhiều lần thất bại

Khi nhận ra mình đã làm hỏng một thẻ nhiều lần, tôi sẽ kiểm tra mã đó trong bảng điều khiển hoặc thực hiện tương đương (ví dụ: đối với các lệnh Vim, tôi sẽ nhấn phím tắt vào Vim). Tôi thực hiện thao tác này ít nhất hai lần liên tiếp. Thao tác này giúp các ngón tay của tôi học lệnh, chứng minh với tôi rằng mã hoạt động và giúp tôi hiểu ngữ cảnh, kết quả là tôi có nhiều khả năng nhớ lệnh hơn vào lần sau.

### 10\. Động não về cách sử dụng thẻ. Hoặc xóa thẻ.

Khi xem lại các thẻ về các tính năng lập trình mà tôi chưa từng sử dụng, tôi tự hỏi: Tính năng này có khả năng áp dụng kém trong thế giới thực hay lỗi nằm ở tôi vì không nỗ lực tìm ra các trường hợp sử dụng? Để trả lời, tôi sẽ động não về các cách sử dụng tính năng này trong các dự án hiện tại của mình, ngay cả khi theo cách vô lý. Thực hành này giúp tôi rèn luyện khả năng áp dụng kiến ​​thức của mình, và trong những trường hợp tôi không nghĩ ra được cách sử dụng nào tốt, tôi thừa nhận sẽ đánh bại và cắt tỉa bộ bài của mình bằng cách xóa thẻ.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/brainstorm-uses.jpeg)

### 11\. In đậm Điểm chính

Bạn sẽ luôn muốn thực hiện các biện pháp để giảm thời gian dành cho việc xem lại bộ bài của mình. Một giải pháp đơn giản và hiệu quả là in đậm từ khóa hoặc điểm chính trong câu hỏi hoặc câu trả lời hoặc cả hai. Kỹ thuật này đặc biệt hữu ích khi bạn có một số thẻ ghi nhớ xử lý các điểm tương tự, ví dụ như giải thích về các ngoại lệ khác nhau trong một không gian tên hoặc lớp duy nhất. Nhờ nhiều năm quét văn bản trực tuyến, mắt bạn đã thích nghi tốt với việc nhìn rõ văn bản in đậm và tôi đã phát hiện ra rằng chỉ cần nhìn thấy phông chữ in đậm trong thẻ Anki của bạn là đủ để khơi gợi trí nhớ và đưa ra câu trả lời cần thiết, giúp bạn tiết kiệm thời gian mà nếu không thì bạn sẽ phải đọc toàn bộ thẻ. Hãy kích hoạt trí nhớ nhanh nhất có thể trong các bài đánh giá của mình rồi tiếp tục.

##### Nếu không in đậm, sẽ rất khó để quét...

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/unbolded.jpeg)

##### ... so sánh với phiên bản \_có\_ in đậm

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/bolded.jpeg)

### 12\. Thẻ thực hành tốt nhất

Bất cứ khi nào tôi học được về một thực hành tốt nhất, có thể là thông qua việc ghép đôi với một lập trình viên giỏi hơn, xem màn hình phát trực tiếp hoặc đọc bình luận trên Github, tôi đều biến ý tưởng đó thành một thẻ. Cho đến nay vẫn chưa có gì bất ngờ. Khi xem lại các thẻ thực hành tốt nhất của mình, tôi áp dụng cách tiếp cận khác với các thẻ thông tin thông thường ở chỗ tôi "trượt" thẻ nếu tôi chưa triển khai thực hành đó trong quy trình làm việc của mình gần đây. Không giống như trong các thẻ thông tin thuần túy, việc tôi nhớ về sự tồn tại của thực hành tốt nhất là không liên quan; mục tiêu của các thẻ thực hành tốt nhất là để tôi áp dụng thực hành đó và cảm giác tội lỗi khi liên tục thất bại thúc đẩy tôi đi đúng hướng.

### 13\. Thẻ câu đố và giải thích

Đôi khi bạn không muốn chỉ học các sự kiện và bạn cần học một kỹ thuật, phương pháp luận hoặc thuật toán tinh thần thay thế. Vì những mục đích này (ví dụ: học phép nhân toán nhị phân), tôi đã tạo các thẻ có câu đố trong câu hỏi và giải pháp trong câu trả lời. Bất cứ khi nào xem lại các thẻ này, tôi cố gắng giải câu đố ngay tại chỗ và trượt thẻ nếu tôi trả lời sai. Tôi thấy cần phải đưa ra lời giải thích về cách tôi giải quyết vấn đề (tức là phương pháp luận) vào thẻ trả lời, để tôi có thể tự nhắc nhở mình cách giải quyết nếu tôi giải sai.

##### So sánh hai thẻ này: một thẻ không có lời giải thích:

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/no-explanation.jpeg)

##### ...Và một thẻ có:

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/explanation.jpeg)

Một biến thể liên quan là tôi tạo các thẻ có câu trả lời cho các lỗi/lệnh chỉ xảy ra một lần nhưng có giải thích sâu về lệnh đang đề cập.
