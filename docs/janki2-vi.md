Bài được dịch bởi Google Dịch và chưa chỉnh sửa.

Trong vài năm trở lại đây, tôi đã [làm ầm ĩ](http://www.jackkinsella.ie/2011/12/05/janki-method.html) về [sử dụng thẻ ghi nhớ lặp lại cách quãng để tăng tốc quá trình học lập trình.](http://www.oxbridgenotes.com/other/web_development_flashcards) Tôi biết rằng tính mới lạ của một ý tưởng có thể làm lu mờ đánh giá hợp lý về tính hữu ích của nó, vì vậy mục đích của bài đăng này là theo dõi sự nhiệt tình ban đầu của tôi và tinh chỉnh phương pháp luận của tôi sau một năm kinh nghiệm trong việc đánh giá thẻ hàng ngày không bao giờ thất bại.

Tôi đã cô đọng điều này thành dạng điểm để tiết kiệm thời gian cho cả hai chúng ta. Mỗi tiểu mục đại diện cho một nguyên tắc mà tôi đã áp dụng trong chiến lược học tập của mình, mục tiêu bao quát là nghiên cứu càng nhiều tài liệu càng tốt trong thời gian ngắn nhất.

### 1\. Thẻ ảnh chụp màn hình > Thẻ văn bản thuần túy.

Trong phương pháp ban đầu của mình, tôi đã dán các đoạn mã văn bản thuần túy vào bộ bài của mình. Bây giờ tôi chụp ảnh màn hình (sử dụng phím tắt) các ví dụ mã từ các chương trình tôi mở trong trình soạn thảo văn bản, từ sách lập trình và từ các trang web như Stack Overflow. Tôi tiết kiệm được thời gian, không cần phải nhập lại mã vào Anki. Tôi cũng được tô sáng cú pháp miễn phí, cho phép tôi đọc thẻ nhanh hơn và tăng tốc độ đánh giá của mình.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/scrapbook-expert.jpeg)

Cho phép tôi thêm một số trực giác khoa học không nghiêm ngặt theo phong cách Tim Ferris: Tôi tin rằng ảnh chụp nguồn gốc của sự kiện được ghi trên thẻ nhớ flash của bạn hỗ trợ trí nhớ trên cơ sở i) trí nhớ dựa trên vị trí mạnh hơn những loại khác; và ii) màu sắc, phông chữ và URL trang web tạo ra trí nhớ phong phú hơn, độc đáo hơn so với một thẻ văn bản khác và do đó dễ dàng đưa vào bộ nhớ hơn một chút.

### 2\. Tập trung vào chức năng có sẵn thay vì thông tin chi tiết

Ban đầu, tôi đưa thông tin chi tiết về mọi chức năng vào bộ bài của mình, bao gồm tên lớp, giá trị trả về và kiểu của chúng, danh sách đối số, thứ tự của chúng. Qua nhiều năm, tôi thấy rằng thông tin này trở nên khó nhớ khi bạn thêm các ngôn ngữ lập trình khác vào hỗn hợp, đặc biệt là những ngôn ngữ có tên hàm tương tự (ví dụ: each()) nhưng cách sử dụng hơi khác một chút. Việc chuyển từ ngôn ngữ này sang ngôn ngữ khác khiến tôi nhận ra rằng thông tin chi tiết như vậy mang lại lợi thế ngắn hạn về tốc độ nhưng nhanh chóng trở nên cũ kỹ. Tuy nhiên, tôi rất vui vì mình có một ngôn ngữ "mẹ đẻ" (Ruby đối với tôi) ở mức độ quen thuộc này vì điều đó có nghĩa là tôi có thể phác thảo phần mềm tiện ích cá nhân, tập lệnh và bản hack một cách nhanh chóng.

Quan trọng hơn là phải ghi nhớ là nhận thức về _những_ chức năng tích hợp nào tồn tại trong một ngôn ngữ và những dịch vụ nào tồn tại trong một hệ điều hành hoặc giao thức. Tôi tạo thẻ cho nhiều lệnh linux khác nhau hoặc các thuộc tính cửa sổ tích hợp Javascript hữu ích.

Đôi khi, tôi tạo ra cái mà tôi gọi là "thẻ lai" kết hợp tóm tắt về lệnh _là_ gì với các chi tiết về hoạt động của lệnh đó. Để làm được điều này, tôi làm theo câu trả lời cơ bản "nó là gì" với mô tả chi tiết hoặc ảnh chụp màn hình mã đang sử dụng (có đối số và đầu ra thực tế), tương tự như cách người học ngôn ngữ cung cấp vốn từ vựng mới bằng các câu ví dụ. Khi xem lại các thẻ, tôi tùy ý liếc qua ví dụ về hàm đang sử dụng, nhưng tôi không cố gắng học thuộc lòng. Nếu sau này, tôi tình cờ cần tính năng cụ thể đó cho một dự án, tôi có thể tách riêng các thẻ đó (sử dụng chức năng khoan của Anki) và tìm hiểu thông tin chi tiết hơn.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/hybrid.jpeg)

### 3\. Thẻ sổ lưu niệm

Các nhà thiết kế đồ họa lưu giữ sổ lưu niệm về tác phẩm nghệ thuật và thiết kế mà họ ngưỡng mộ, sau đó tham khảo sổ lưu niệm của họ khi tìm kiếm cảm hứng cho các dự án trong tương lai. Các lập trình viên cũng có thể làm như vậy. Bất cứ khi nào bạn thấy một đoạn mã đặc biệt thanh lịch, hiệu quả hoặc thông minh trong thư viện, bài đăng trên blog hoặc ghi chú hoặc chụp ảnh màn hình rồi đặt vào bộ bài của bạn.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/characterising-variable-names.jpeg)

Để chuyển đổi ảnh chụp ví dụ về mã thành cặp câu hỏi/trả lời thân thiện với Anki, tôi tạo một thẻ có câu hỏi trước ảnh chụp màn hình, đại loại như: "Đoạn mã này có gì tuyệt vời?". Trong câu trả lời, tôi xác định điểm mạnh của kỹ thuật bằng các dấu đầu dòng, buộc bản thân phải xác định và diễn đạt bằng lời những điều mình học được, thay vì chỉ để đó là lời cảm ơn mơ hồ không lời.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/abstain-generic-variable-names.jpeg)

Đôi khi tôi đảo ngược quy trình này và phân tích mã tệ hại, tạo thẻ "Cái này có vấn đề gì?", một lần nữa xây dựng các quy tắc hoặc đơn thuốc chống lại những gì tệ hại. Mục tiêu cuối cùng của cả hai quy trình này là nhận thức nhanh chóng về chất lượng trong chương trình lập trình của riêng tôi.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/IMG_669C6DDCBEB9-1.jpeg)

### 4\. Thông tin có thứ tự không ankify tốt

Ban đầu tôi nghĩ rằng bất kỳ và tất cả các kiến ​​thức kỹ thuật đều ankify tốt. Kể từ đó, tôi đã giảm bớt sự nhiệt tình của mình iasm và nhận thấy một ngoại lệ chính: thông tin mà thứ tự/cấu trúc là cần thiết. Ví dụ, tôi đã tạo các thẻ mở rộng về thiết lập khóa SSH trên máy chủ, một điệu nhảy phức tạp, nhiều bước giữa máy tính xách tay của bạn và máy chủ từ xa của bạn. Mặc dù đã xem lại Anki-fed, tôi không bao giờ nhớ toàn bộ quy trình đã sắp xếp trong thực tế và luôn phải dùng đến hướng dẫn trực tuyến. Thời gian tôi ank hóa và xem lại các quy tắc SSH đã bị lãng phí.

Tôi không chắc nguyên nhân chính xác khiến mình thất bại. Có lẽ tôi đã tạo thẻ ghi nhớ không đúng cho loại thông tin này và tôi có thể đã sửa bằng các thẻ ghi nhớ SSH bổ sung đặt câu hỏi rõ ràng về hành động nào diễn ra trước hoặc sau hành động khác. Nhưng trực giác của tôi cho thấy việc tạo quá nhiều thẻ bổ sung là lãng phí thời gian và tôi muốn giữ lại và dùng đến danh sách kiểm tra hoặc sơ đồ đã cập nhật của quy trình đã sắp xếp.

### 5\. Tạm dừng công nghệ khi đang chờ. Thực hành khi cần.

Tôi quyết định rằng các công nghệ bên lề (ngôn ngữ, thư viện, bộ tính năng và khái niệm hiếm khi được sử dụng trong công việc của tôi) không phải là cách sử dụng tốt cho thời gian đánh giá hạn hẹp của tôi và sau khi tôi đánh giá tài liệu này trong bối cảnh của một dự án sử dụng chúng (ví dụ: sử dụng Backbone cho ứng dụng web vào năm ngoái), tôi tạm dừng đánh giá các thẻ đó. Nếu có một dự án khác sử dụng công nghệ đó, tôi sử dụng **chức năng khoan** của Anki để nhanh chóng sửa đổi công nghệ trước khi bắt tay vào thực hiện. Nếu dự án đó không bao giờ thành hiện thực, tôi sẽ tạm dừng các thẻ vô thời hạn, có lẽ sẽ không bao giờ sử dụng lại nữa.

Bạn có thể chỉ ra rằng việc tạo thẻ Anki cho công nghệ bên lề là lãng phí ngay từ đầu‚Äî có thể là đối với bạn nhưng i) Tôi thấy khó xác định công nghệ bên lề so với công nghệ cốt lõi khi lần đầu tiên tiếp xúc và hơn nữa, ii) Tôi thấy tính kỷ luật khi chủ động chuyển tài liệu kỹ thuật thành câu hỏi và câu trả lời giúp tôi tập trung vào việc đọc và giúp tôi thẩm vấn văn bản để có thông tin có thể hành động nhanh hơn.

### 6\. Giảm Cường Độ

Lý thuyết sử dụng SRS chuẩn (do P. Wozniak đưa ra) yêu cầu chúng ta xem lại tất cả các lá bài trong bộ bài của mình đến hạn vào bất kỳ ngày cụ thể nào để ghi nhớ kiến ​​thức vào bộ nhớ dài hạn với hiệu quả cao nhất có thể. Tôi đã thử cách này trong khoảng hai năm nhưng cuối cùng tôi thấy gánh nặng xem lại quá lớn. Để khắc phục điều này, tôi đã giới hạn số lượng bài xem lại tối đa trong bộ bài lập trình của mình ở mức 40 lá bài mỗi ngày và sửa đổi cài đặt bộ bài trong Anki để tăng phần thưởng dễ (thời gian thêm giữa các lá bài bạn đánh dấu là dễ) và bộ điều chỉnh khoảng thời gian (thời gian giữa các lần xem lại _bất kỳ_ lá bài nào). Hiệu ứng của tùy chọn khoảng cách dễ là hiển thị các lá bài dễ ít thường xuyên hơn (chúng không gây ra thử thách liên tục cho tôi, thường là nền tảng cho các khái niệm nâng cao hơn trong bộ bài của tôi, vì vậy sự đánh đổi là hợp lý), trong khi bộ điều chỉnh khoảng thời gian điều chỉnh thuật toán để giãn cách tất cả các lá bài xa hơn bất kể độ khó, nghĩa là nhiều ngày hơn giữa mỗi lần xem lại và do đó ít bài xem lại hơn vào bất kỳ buổi sáng cụ thể nào.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/lower-intensity.jpeg)

Cái giá tôi phải trả cho thời gian ôn tập giảm này là tôi có thể không ôn tập theo "đường cong quên", nghĩa là một chiến lược học tập kém hiệu quả trên toàn cầu. Tôi chấp nhận điều này vì tôi nhận ra rằng các ngôn ngữ lập trình đến rồi đi và tôi nhận ra rằng tôi có thể không lập trình trong 10 năm nữa‚Äîmục tiêu chính của tôi là lập trình nhanh như tôi có thể rèn luyện bản thân ngày hôm nay. Bên cạnh đó, việc giảm hiệu quả là cái giá hợp lý phải trả nếu nó đảm bảo bạn tuân thủ thói quen ôn tập, thực hiện chức năng tương tự như những ngày gian lận trong chế độ ăn kiêng giảm cân khó khăn.

### 7\. Đọc có đánh số

Bất cứ khi nào tôi đọc sách giáo khoa lập trình in, tôi đều đánh số (1,2,3...) vào lề bên cạnh bất kỳ điểm nào tôi muốn cam kết sau này với Anki, cùng với một lời nhắc ngắn, ví dụ: "hiệu quả của hệ thống tệp". Sau khi đọc xong cuốn sách, tôi lại lướt qua nó một lần nữa, thêm một thẻ vào Anki cho mỗi điểm được đánh số mà tôi vẫn thấy đáng nhớ.

Lý do tôi làm như vậy là i) không làm gián đoạn dòng đọc bằng cách cúi xuống máy tính xách tay và đánh dấu từng điểm tôi gặp phải, do đó tiết kiệm thời gian bằng cách nhóm và ii) để tính đến cách tác giả sách giáo khoa đôi khi trình bày một điểm rõ ràng hơn trong các chương sau và chỉ sử dụng lời giải thích tốt nhất trong bộ thẻ ghi nhớ của tôi.

### 8\. Nhấn mạnh các meme bất biến của ngôn ngữ

Khi học ngôn ngữ lập trình và thư viện, tôi nhận ra rằng một phần giá trị của việc áp dụng phương pháp Janki trong ngôn ngữ lập trình đầu tiên của tôi, Ruby, là học các "meme" lặp lại trong các ngôn ngữ khác. Ví dụ, các phương thức "chức năng" trong mô-đun Enumerable của Ruby, chẳng hạn như each(), map(), select(), reject() và zip() lặp lại dưới cùng tên hoặc tên tương tự trong Javascript, Lisp, Python và nhiều thư viện khác (chẳng hạn như thư viện Underscore của Javascript). Biết ý nghĩa của các hàm này và cách sử dụng chúng sẽ giúp giảm thời gian học một môi trường mới. Tương tự như vậy, việc tìm hiểu chi tiết về cách Linux tương tác với các tệp làm sáng tỏ các phương thức tương tác Tệp/IO trong Ruby, C và Pyth trên.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/explanation-card.jpeg)

Tôi không có cách nào chắc chắn để phân biệt các meme bất biến ngôn ngữ với các ý tưởng "chỉ dành cho ngôn ngữ này", ngoại trừ một vài quy tắc chung. Ví dụ về mã thanh lịch hoặc mã xấu xí (chẳng hạn như số ma thuật) thường có sự tương đồng trong các môi trường khác (hoặc, nếu chưa song song, thì thực hành này có thể được thụ phấn chéo hiệu quả); các hàm tương tác với Hệ điều hành cơ bản (luồng, IO), miễn là chúng không bị trừu tượng hóa, tái sử dụng các khái niệm giống như các ngôn ngữ khác chạy trên các hệ thống tương tự (linux, Android, iOS, Windows); nhiều ngôn ngữ chia sẻ cùng các ý tưởng về biểu thức chính quy (mặc dù có nhiều cú pháp khác nhau); các khái niệm như toán nhị phân, mã hóa chuỗi, tối ưu hóa hiệu suất, gỡ lỗi và lập trình hướng đối tượng vẫn tồn tại mạnh mẽ qua các rào cản ngôn ngữ.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/IMG_4F99DF5CCBF2-1.jpeg)

### 9\. Tự chạy mã sau nhiều lần thất bại

Khi nhận ra mình đã làm hỏng một thẻ nhiều lần, tôi sẽ kiểm tra mã đó trong bảng điều khiển hoặc thực hiện tương đương (ví dụ: đối với các lệnh Vim, tôi sẽ nhấn phím tắt vào Vim). Tôi thực hiện thao tác này ít nhất hai lần liên tiếp. Thao tác này giúp các ngón tay của tôi học lệnh, chứng minh với tôi rằng mã hoạt động và giúp tôi hiểu ngữ cảnh, kết quả là tôi có nhiều khả năng nhớ lệnh hơn vào lần sau.

### 10\. Động não về cách sử dụng thẻ. Hoặc xóa thẻ.

Khi xem lại các thẻ về các tính năng lập trình mà tôi chưa từng sử dụng, tôi tự hỏi: Tính năng này có khả năng áp dụng kém trong thế giới thực hay lỗi nằm ở tôi vì không nỗ lực tìm ra các trường hợp sử dụng? Để trả lời, tôi sẽ động não về các cách sử dụng tính năng này trong các dự án hiện tại của mình, ngay cả khi theo cách vô lý. Thực hành này giúp tôi rèn luyện khả năng áp dụng kiến ​​thức của mình, và trong những trường hợp tôi không nghĩ ra được cách sử dụng nào tốt, tôi thừa nhận sẽ đánh bại và cắt tỉa bộ bài của mình bằng cách xóa thẻ.

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/brainstorm-uses.jpeg)

### 11\. In đậm Điểm chính

Bạn sẽ luôn muốn thực hiện các biện pháp để giảm thời gian dành cho việc xem lại bộ bài của mình. Một giải pháp đơn giản và hiệu quả là in đậm từ khóa hoặc điểm chính trong câu hỏi hoặc câu trả lời hoặc cả hai. Kỹ thuật này đặc biệt hữu ích khi bạn có một số thẻ ghi nhớ xử lý các điểm tương tự, ví dụ như giải thích về các ngoại lệ khác nhau trong một không gian tên hoặc lớp duy nhất. Nhờ nhiều năm quét văn bản trực tuyến, mắt bạn đã thích nghi tốt với việc nhìn rõ văn bản in đậm và tôi đã phát hiện ra rằng chỉ cần nhìn thấy phông chữ in đậm trong thẻ Anki của bạn là đủ để khơi gợi trí nhớ và đưa ra câu trả lời cần thiết, giúp bạn tiết kiệm thời gian mà nếu không thì bạn sẽ phải đọc toàn bộ thẻ. Hãy kích hoạt trí nhớ nhanh nhất có thể trong các bài đánh giá của mình rồi tiếp tục.

##### Nếu không in đậm, sẽ rất khó để quét...

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/unbolded.jpeg)

##### ... so sánh với phiên bản \_có\_ in đậm

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/bolded.jpeg)

### 12\. Thẻ thực hành tốt nhất

Bất cứ khi nào tôi học được về một thực hành tốt nhất, có thể là thông qua việc ghép đôi với một lập trình viên giỏi hơn, xem màn hình phát trực tiếp hoặc đọc bình luận trên Github, tôi đều biến ý tưởng đó thành một thẻ. Cho đến nay vẫn chưa có gì bất ngờ. Khi xem lại các thẻ thực hành tốt nhất của mình, tôi áp dụng cách tiếp cận khác với các thẻ thông tin thông thường ở chỗ tôi "trượt" thẻ nếu tôi chưa triển khai thực hành đó trong quy trình làm việc của mình gần đây. Không giống như trong các thẻ thông tin thuần túy, việc tôi nhớ về sự tồn tại của thực hành tốt nhất là không liên quan; mục tiêu của các thẻ thực hành tốt nhất là để tôi áp dụng thực hành đó và cảm giác tội lỗi khi liên tục thất bại thúc đẩy tôi đi đúng hướng.

### 13\. Thẻ câu đố và giải thích

Đôi khi bạn không muốn chỉ học các sự kiện và bạn cần học một kỹ thuật, phương pháp luận hoặc thuật toán tinh thần thay thế. Vì những mục đích này (ví dụ: học phép nhân toán nhị phân), tôi đã tạo các thẻ có câu đố trong câu hỏi và giải pháp trong câu trả lời. Bất cứ khi nào xem lại các thẻ này, tôi cố gắng giải câu đố ngay tại chỗ và trượt thẻ nếu tôi trả lời sai. Tôi thấy cần phải đưa ra lời giải thích về cách tôi giải quyết vấn đề (tức là phương pháp luận) vào thẻ trả lời, để tôi có thể tự nhắc nhở mình cách giải quyết nếu tôi giải sai.

##### So sánh hai thẻ này: một thẻ không có lời giải thích:

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/no-explanation.jpeg)

##### ...Và một thẻ có:

![](https://confessions-production.s3.amazonaws.com/uploads/janki-refined-images/explanation.jpeg)

Một biến thể liên quan là tôi tạo các thẻ có câu trả lời cho các lỗi/lệnh chỉ xảy ra một lần nhưng có giải thích sâu về lệnh đang đề cập.
